<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Git 分支管理规范]]></title>
      <url>%2F2018%2F09%2F12%2FGit-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[本文不涉及git指令的介绍，侧重于分支管理，个人理解分支管理并没有正确与否，重要在于是否成体系，简单来说就是能否高效的应对所有情况。没有对比就没有伤害，先看两种比较出名的分支管理方式: Git flow原文链接根红苗正，很多注重流程的大公司都在使用。先看一张总览图：大家可以仔细看一下这幅图，带着问题继续向下看 概念在上图中有如下几个概念： 时间线：这个就不多说了，牵扯到一些哲学问题 master：生产分支，和生产版本一一对应 develop分支：日常开发所在分支 feature分支：功能开发所在分支 release分支：预发版本 hotfixes分支：修复线上bug的分支（哎。。希望大家都用不到。。） master &amp; develop这是最核心的两个分支，从图上可以看出，他们的时间线是两根实现，意味着这两个分支是永存的。 首先master分支，大家应该很熟悉，在这里它始终代表着生产环境的状态。 develop分支，在它上面最新提交的代码始终代表着下一个release的改动。当develop分支的代码达到一种可以release的稳定状态时，所有的改变都应该以某种方式合并会master上，并且打上release的tag。后面会聊如何合并回master。(见release的介绍) 辅助分支在两个核心分支之外，我们还有几个辅助分支，用于支撑多团队开发，新功能开发，准备生产release，快速修复生产bug等问题。这些分支的生命周期是有限的，最终都会被删除。 这些分支是： feature分支 release分支 hotfix分支 上述的每个分支都有特殊的目的，并且有严格的规范，比如它们源于哪个分支，最终必须合并到哪个分支，下面我们就来讨论这个。 注：这里的辅助分支从技术层面上来看并无任何特殊之处 feature分支源于：develop合并回：develop命名规范：除了master, develop, release-*, hotfix-*外的所有名字，建议以feature/开头feature分支用于为即将到来的或者是以后的release开发新功能。在刚开始开发feature分支时，可能并不知道它将会被合并到哪个release中。feature分支的本质是只要feature在开发，它就一直存在，直到合并到develop或者丢弃。 操作步骤 创建分支从develop分支开辟feature分支 12$ git checkout -b feature/myfeature developSwitched to a new branch &quot;feature/myfeature&quot; 把完成的feature分支合并回develop完成的feature分支将被合并回develop，以确保它能出现在即将发布的release中。 12345678$ git checkout developSwitched to branch &apos;develop&apos;$ git merge --no-ff feature/myfeatureUpdating ea1b82a..05e9557(Summary of changes)$ git branch -d feature/myfeatureDeleted branch feature/myfeature (was 05e9557).$ git push origin develop –no-ff即便在fast-forward的情况下也会增加一个commit对象，它方便记录feature的情况。下图比较了加与不加的区别： 不加–no-ff会导致你无法找到feature是哪个提交，你只能人工的读每一个提交log，然后找到那些提交。虽然加了–no-ff会增加一个空的commit对象，但是和获得的好处比就显得微不足道了。 release 分支源于：develop合并回：develop，master命名规范：release-* 用于准备新的生产发布，它也可以在最后关头做微量修改。比如很小的bug修复，生产元数据的准备等。release会在develop分支达到生产新版本预期的状态时，从develop中开辟出来。此时所有想要出现在即将发布的生产版本的feature都应该已经合并到develop，所有希望在以后的生产版本中发布的feature都不能在develop分支中。 操作步骤 创建release分支release是从develop分支开辟出来的。比如1.1.5是当前的版本，我们现在有一个大的版本即将到来，并且develop分支已经做好该版本的准备，并且我们决定给这个即将到来的版本取名为1.2版本：12345$ git checkout -b release-1.2 developSwitched to a new branch &quot;release-1.2&quot;$ git commit -a -m &quot;Bumped version number to 1.2&quot;[release-1.2 74d9424] Bumped version number to 1.21 files changed, 1 insertions(+), 1 deletions(-) 这个新的分支将会存在一段时间，知道版本发布，在这段时间中，可以在该分支上修复bug(而不是在develop分支)。但是禁止添加大的feature，新的feature必须合并到develop，然后等待下个版本的到来。 完成分支当release分支已经做好成为新版本的准备的时候，要完成如下几步，首先，releas分支要合并到master上(谨记！！！master上的每一个提交都是release)。接着，master上打上版本标签。最后，release上的改动要合并回develop，以确保后面的版本中能包含bug fix的内容。 前两步如下： 123456$ git checkout masterSwitched to branch &apos;master&apos;$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes)$ git tag -a 1.2 然后把改动merge回develop12345$ git checkout developSwitched to branch &apos;develop&apos;$ git merge --no-ff release-1.2Merge made by recursive.(Summary of changes) 这一步可能有冲突，但是没关系，合并解决它！ 最后，删除它12$ git branch -d release-1.2Deleted branch release-1.2 (was ff452fe). Hotfix分支源于：master合并回：develop/release，master命名规范：hotfix-*hotfix和release分支非常像，它们都是为新版本准备的。当线上环境出现严重的bug时，hotfix分支会从master分支开辟出来，这时在develop分支开发的人可以继续开发，负责修复bug的人可以在该分支上修复bug。 操作步骤 创建hotfix分支比如当前版本为1.2，生产遇到严重问题，但是develop尚不稳定。我们需要开辟一个hotfix分支，然后修复这个问题：12345$ git checkout -b hotfix-1.2.1 masterSwitched to a new branch &quot;hotfix-1.2.1&quot;$ git commit -a -m &quot;Bumped version number to 1.2.1&quot;[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.11 files changed, 1 insertions(+), 1 deletions(-) 然后修复该问题，提交123$ git commit -m &quot;Fixed severe production problem&quot;[hotfix-1.2.1 abbe5d6] Fixed severe production problem5 files changed, 32 insertions(+), 17 deletions(-)s 完成hotfix分支当完成hotfix之后，hotfix分支需要合并到master，还需要合并到develop中，确保下个版本中会包含该hotfix，这点和release非常像。 更新master，tag版本123$ git commit -m &quot;Fixed severe production problem&quot;[hotfix-1.2.1 abbe5d6] Fixed severe production problem5 files changed, 32 insertions(+), 17 deletions(-) 合并hotfix到develop123$ git commit -m &quot;Fixed severe production problem&quot;[hotfix-1.2.1 abbe5d6] Fixed severe production problem5 files changed, 32 insertions(+), 17 deletions(-) ！！！特殊情况如果当前存在release分支，此时hotfix分支需要合并到release上，而不是develop上。这样当release合并会develop时也能保证develop上有hotfix的内容。（如果这个bug不能等待release，急需合并到develop中，也没关系，大胆的合并到develop吧~）12$ git branch -d hotfix-1.2.1Deleted branch hotfix-1.2.1 (was abbe5d6). 优缺点 优点条理清晰，环环相扣，适合注重流程管理的公司 缺点太复杂feature合并到develop分支后，如果计划有变不希望它出现在下个release中时会很麻烦多环境集成测试比较麻烦 AoneFlow阿里巴巴用的分支管理方式。从功能上来说是集大成者，灵活，简单，能满足各种需求。缺点暂时不说，我们先看一下吧。 AoneFlow只有三类分支 + 三条基本规则 分支 主干分支：master 特性分支：开发所在分支 发布分支：想要想主干发布的分支 规则1.所有特性分支由主干创建从代表最新已发布版本的主干上创建一个特性分支，一般以feature/为前缀来命名，然后在其上开始开发。 2.合并特性分支生成发布分支这个是精髓所在！！从主干上拉取一条新的分支，将所有本次要集成或发布的特性分支一次合并过去，从而得到发布分支。发布分支通常以release/为前缀。这个规则看似简单，其实可以玩出很多花样，比如我们可以将发布分支和环境对应起来，release/test对应测试环境，release/dev对应开发环境，release/prod对应线上正式环境。所有分发布分支都是动态组成的，这样带来的优点是调整起来特别方便。比如，项目就要上线了，“无敌的”甲方要求去掉某个功能，这时如果按照往常的办法，feature分支肯定已经在develop分支上了，只能手工剔除代码了。但是在AoneFlow模式下，重建发布分支就是分分钟的事情，三步走，首先删除原来的发布分支，然后从主干拉取新的同名发部分支，最后把需要保留的特性分支合并过来。这一系列操作可以很简单的自动化，并且干净无污染。 此外，发布分支之间是松耦合的，这样就可以有多个集成环境分别进行不同的特性组合的集成测试，也能方便的管理各个特性进入到不同环境上部署的时机。松耦合并不代表没有相关性，由于测试环境、集成环境、预发布环境、灰度环境和线上正式环境等发布流程通常是顺序进行的，在流程上可以要求只有通过前一环境验证的特性，才能传递到下一个环境做部署，形成漏斗形的特性发布流。 3. 发布到线上正式环境后，合并相应的发布分支到主干，在主干添加标签，同时删除该发布分支&amp;关联的特性分支当一条发布分支上的流水线完成了一次线上正式环境的部署，就意味着相应的功能真正的发布了，此时应该将这条发布分支合并到主干。为了避免在代码仓库里堆积大量历史上的特性分支，还应该清理掉已经上线部分特性分支。与 GitFlow 相似，主干分支上的最新版本始终与线上版本一致，如果要回溯历史版本，只需在主干分支上找到相应的版本标签即可。 优缺点优点： 简单，清晰，能应对各种情况缺点： 需要一套自动化工具，否则发布分支的创建，维护，重建等工作会把人干蹦 ————————— 我是分割线 ————————– 我们用什么？那么问题来了，我们应该怎么办呢？以下为个人臆想，如有不对请指出。首先，我不想用第一种方式，太繁琐，而且死板，所以大的基调定为第二种方案。但是，我们当前又没有非常好的CI/CD工具，生搬硬套难度较大，主要问题如下： 发布分支的灵活性带来了极大的复杂性，手动维护是个噩梦 无法限制分支提交顺序，比如当一个分支想要发布到线上时，很难判断它经过了dev-&gt;test-&gt;staging的验证 所以，有以下改动点： 沿用主干分支，特性分支，发布分支的概念，但是同一时刻，只有3个发布分支，分别是release/dev, release/test,release/staging分别对应着开发发布分支（用于发布到开发环境），测试发布分支（发布到测试环境），预发发布分支（发布到预发环境) 发布分支的上线步骤dev-&gt;test-&gt;staging-&gt;生产比如：上述例子中，开始我们有3个特性分支需要开发，1.0.0版本只需特性分支1上线]]></content>
    </entry>

    
  
  
</search>
